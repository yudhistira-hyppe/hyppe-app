"use strict";

// src/webhooks/resources/verify_header.ts
import crypto from "crypto";
var HeaderScheme = {
  V1: "v1"
};
var DEFAULT_TOLERANCE = 300;
var EXPECTED_SCHEME = HeaderScheme.V1;
function secureCompare(_a, _b) {
  const a = Buffer.from(_a);
  const b = Buffer.from(_b);
  if (a.length !== b.length) {
    return false;
  }
  if (crypto.timingSafeEqual) {
    return crypto.timingSafeEqual(a, b);
  }
  const len = a.length;
  let result = 0;
  for (let i = 0; i < len; i += 1) {
    result |= a[i] ^ b[i];
  }
  return result === 0;
}
var VerifyHeader = class {
  static parseHeader(header, scheme = HeaderScheme.V1) {
    if (typeof header !== "string") {
      return null;
    }
    if (scheme !== EXPECTED_SCHEME) {
      throw new Error(`Unrecognized header scheme: '${scheme}'`);
    }
    return header.split(",").reduce((accum, item) => {
      const kv = item.split("=");
      if (kv[0] === "t") {
        accum.timestamp = parseInt(kv[1], 10);
      }
      if (kv[0] === scheme && typeof kv[1] === "string") {
        accum.signatures.push(kv[1]);
      }
      return accum;
    }, {
      timestamp: -1,
      signatures: []
    });
  }
  static computeSignature(payload, secret) {
    return crypto.createHmac("sha256", secret).update(payload, "utf8").digest("hex");
  }
  static verify(_payload, _header, secret, tolerance = DEFAULT_TOLERANCE) {
    const payload = Buffer.isBuffer(_payload) ? _payload.toString("utf8") : _payload;
    const header = Buffer.isBuffer(_header) ? _header.toString("utf8") : _header;
    const details = this.parseHeader(header);
    if (!details || details.timestamp === -1) {
      throw new Error("Unable to extract timestamp and signatures from header");
    }
    if (!details.signatures.length) {
      throw new Error("No signatures found with expected scheme");
    }
    const expectedSignature = this.computeSignature(`${details.timestamp}.${payload}`, secret);
    const signatureFound = !!details.signatures.filter((sig) => secureCompare(sig, expectedSignature)).length;
    if (!signatureFound) {
      throw new Error("No signatures found matching the expected signature for payload.");
    }
    const timestampAge = Math.floor(Date.now() / 1e3) - details.timestamp;
    if (tolerance > 0 && timestampAge > tolerance) {
      throw new Error("Timestamp outside the tolerance zone");
    }
    return true;
  }
};
export {
  HeaderScheme,
  VerifyHeader
};
//# sourceMappingURL=verify_header.mjs.map