"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/webhooks/resources/verify_header.ts
var verify_header_exports = {};
__export(verify_header_exports, {
  HeaderScheme: () => HeaderScheme,
  VerifyHeader: () => VerifyHeader
});
module.exports = __toCommonJS(verify_header_exports);
var import_crypto = __toESM(require("crypto"));
var HeaderScheme = {
  V1: "v1"
};
var DEFAULT_TOLERANCE = 300;
var EXPECTED_SCHEME = HeaderScheme.V1;
function secureCompare(_a, _b) {
  const a = Buffer.from(_a);
  const b = Buffer.from(_b);
  if (a.length !== b.length) {
    return false;
  }
  if (import_crypto.default.timingSafeEqual) {
    return import_crypto.default.timingSafeEqual(a, b);
  }
  const len = a.length;
  let result = 0;
  for (let i = 0; i < len; i += 1) {
    result |= a[i] ^ b[i];
  }
  return result === 0;
}
var VerifyHeader = class {
  static parseHeader(header, scheme = HeaderScheme.V1) {
    if (typeof header !== "string") {
      return null;
    }
    if (scheme !== EXPECTED_SCHEME) {
      throw new Error(`Unrecognized header scheme: '${scheme}'`);
    }
    return header.split(",").reduce((accum, item) => {
      const kv = item.split("=");
      if (kv[0] === "t") {
        accum.timestamp = parseInt(kv[1], 10);
      }
      if (kv[0] === scheme && typeof kv[1] === "string") {
        accum.signatures.push(kv[1]);
      }
      return accum;
    }, {
      timestamp: -1,
      signatures: []
    });
  }
  static computeSignature(payload, secret) {
    return import_crypto.default.createHmac("sha256", secret).update(payload, "utf8").digest("hex");
  }
  static verify(_payload, _header, secret, tolerance = DEFAULT_TOLERANCE) {
    const payload = Buffer.isBuffer(_payload) ? _payload.toString("utf8") : _payload;
    const header = Buffer.isBuffer(_header) ? _header.toString("utf8") : _header;
    const details = this.parseHeader(header);
    if (!details || details.timestamp === -1) {
      throw new Error("Unable to extract timestamp and signatures from header");
    }
    if (!details.signatures.length) {
      throw new Error("No signatures found with expected scheme");
    }
    const expectedSignature = this.computeSignature(`${details.timestamp}.${payload}`, secret);
    const signatureFound = !!details.signatures.filter((sig) => secureCompare(sig, expectedSignature)).length;
    if (!signatureFound) {
      throw new Error("No signatures found matching the expected signature for payload.");
    }
    const timestampAge = Math.floor(Date.now() / 1e3) - details.timestamp;
    if (tolerance > 0 && timestampAge > tolerance) {
      throw new Error("Timestamp outside the tolerance zone");
    }
    return true;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HeaderScheme,
  VerifyHeader
});
module.exports = module.exports.default || module.exports;
//# sourceMappingURL=verify_header.js.map