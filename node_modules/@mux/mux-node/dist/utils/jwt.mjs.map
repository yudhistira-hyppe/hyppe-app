{"version":3,"sources":["../../src/utils/jwt.ts"],"sourcesContent":["/*!\n * JWT - Signed URL Helpers\n * Note: Hacking this module into a class with static methods because ESDoc forces it. We'll revisit ESDoc later.\n * Documentationjs looks real nice.\n */\nimport fs from 'fs';\nimport jwt from 'jsonwebtoken';\n\n// eslint-disable-next-line no-shadow\nexport enum TypeClaim {\n  video = 'v',\n  thumbnail = 't',\n  gif = 'g',\n  storyboard = 's',\n  stats = 'playback_id',\n}\n\n// eslint-disable-next-line no-shadow\nexport enum DataTypeClaim {\n  video = 'video_id',\n  asset = 'asset_id',\n  playback = 'playback_id',\n  live_stream = 'livestream_id',\n}\n\nexport interface MuxJWTSignOptions {\n  keyId?: string;\n  keySecret?: string;\n  keyFilePath?: string;\n  type?: string;\n  expiration?: string;\n  params?: Record<string, string>;\n}\n\nconst getSigningKey = (options: MuxJWTSignOptions) => {\n  const keyId = options.keyId || process.env.MUX_SIGNING_KEY;\n  if (!keyId) {\n    throw new TypeError('Signing Key ID required');\n  }\n\n  return keyId;\n};\n\nconst getPrivateKey = (options: MuxJWTSignOptions): string | Buffer => {\n  let key;\n  if (options.keySecret) {\n    key = options.keySecret;\n  } else if (options.keyFilePath) {\n    key = fs.readFileSync(options.keyFilePath);\n  } else if (process.env.MUX_PRIVATE_KEY) {\n    key = Buffer.from(process.env.MUX_PRIVATE_KEY, 'base64');\n  }\n\n  if (Buffer.isBuffer(key)) {\n    return key;\n  }\n\n  if (key) {\n    const [rsaHeader] = key.toString().split('\\n');\n    if (rsaHeader === '-----BEGIN RSA PRIVATE KEY-----') {\n      return key;\n    }\n\n    try {\n      return Buffer.from(key, 'base64');\n    } catch (err) {\n      throw new TypeError(\n        'Specified signing key must be either a valid PEM string or a base64 encoded PEM.'\n      );\n    }\n  }\n\n  throw new TypeError('Signing Key ID required');\n};\n\n/**\n * JWT - Signed URL token generation helpers\n *\n * @example\n * const Mux = require('@mux/mux-node');\n *\n * const token = Mux.JWT.signPlaybackId('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' })\n */\nexport class JWT {\n  /**\n   * Creates a new token to be used with a signed playback ID\n   * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, `storyboard` or `stats`\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n   * @returns {string} - Returns a token to be used with a signed URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`\n   *\n   * @deprecated This method should not be used, you should use signPlaybackId instead\n   */\n  static sign(playbackId: string, options: MuxJWTSignOptions = {}) {\n    process.emitWarning(\n      'The JWT.sign() method has been deprecated, please use JWT.signPlaybackId() instead',\n      'DeprecatedWarning'\n    );\n    return this.signPlaybackId(playbackId, options);\n  }\n  /**\n   * Creates a new token to be used with a signed playback ID\n   * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, `storyboard` or `stats`\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n   * @returns {string} - Returns a token to be used with a signed URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.signPlaybackId('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`\n   */\n  static signPlaybackId(playbackId: string, options: MuxJWTSignOptions = {}) {\n    const opts = {\n      type: 'video',\n      expiration: '7d',\n      params: {},\n      ...options,\n    };\n\n    const keyId = getSigningKey(options);\n    const keySecret = getPrivateKey(options);\n\n    // TODO: come back through sometime and replace this with runtypes validation?\n    // @ts-ignore\n    const typeClaim = TypeClaim[opts.type];\n    if (!typeClaim) {\n      throw new Error(`Invalid signature type: ${opts.type}`);\n    }\n\n    const tokenOptions: jwt.SignOptions = {\n      keyid: keyId,\n      subject: playbackId,\n      audience: typeClaim,\n      expiresIn: opts.expiration,\n      noTimestamp: true,\n      algorithm: 'RS256',\n    };\n\n    return jwt.sign(opts.params, keySecret, tokenOptions);\n  }\n  /**\n   * Creates a new token to be used with a signed Space ID\n   * @param {string} spaceId - The Space ID (of type 'signed') that you'd like to generate a token for.\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url.\n   * @returns {string} - Returns a token to be used with a signed URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.signSpaceId('some-space-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   */\n  static signSpaceId(spaceId: string, options: MuxJWTSignOptions = {}) {\n    const opts = {\n      expiration: '7d',\n      params: {},\n      ...options,\n    };\n\n    const keyId = getSigningKey(options);\n    const keySecret = getPrivateKey(options);\n\n    const tokenOptions: jwt.SignOptions = {\n      keyid: keyId,\n      subject: spaceId,\n      audience: 'rt',\n      expiresIn: opts.expiration,\n      noTimestamp: true,\n      algorithm: 'RS256',\n    };\n\n    if (!spaceId) {\n      throw new TypeError('A valid Space ID is required');\n    }\n\n    return jwt.sign(opts.params, keySecret, tokenOptions);\n  }\n\n  /**\n   * Creates a new token to be used with a signed statistics request\n   * @param {string} Id - The ID of the object that you'd like to generate a token for\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `asset`, `playback`, or `live_stream`\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n   * @returns {string} - Returns a token to be used with a viewer count URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.signViewerCounts('some-id', { type: 'video', keyId: 'your key id', keySecret: 'your key secret' });\n   * // Now you can use the token in a url: `https://stats.mux.com/counts?token=${token}`\n   */\n  static signViewerCounts(Id: string, options: MuxJWTSignOptions = {}) {\n    const opts = {\n      type: 'video',\n      expiration: '7d',\n      params: {},\n      ...options,\n    };\n\n    const keyId = getSigningKey(options);\n    const keySecret = getPrivateKey(options);\n\n    // TODO: come back through sometime and replace this with runtypes validation?\n    // @ts-ignore\n    const typeClaim = DataTypeClaim[opts.type];\n    if (!typeClaim) {\n      throw new Error(`Invalid signature type: ${opts.type}`);\n    }\n\n    const tokenOptions: jwt.SignOptions = {\n      keyid: keyId,\n      subject: Id,\n      audience: typeClaim,\n      expiresIn: opts.expiration,\n      noTimestamp: true,\n      algorithm: 'RS256',\n    };\n\n    return jwt.sign(opts.params, keySecret, tokenOptions);\n  }\n\n  /**\n   * Decodes an existing token.\n   *\n   * Note: This does not cryptographically verify the token signature, it simply decodes the values.\n   * @param {string} token - The token you'd like to decode.\n   * @returns {Object} - If the token could be decoded, it returns the decoded token object\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * const decoded = Mux.JWT.decode(token);\n   * // decoded will be the raw decoded JWT, so you'll see keys like `aud`, `exp`, etc.\n   */\n  static decode(token: string) {\n    return jwt.decode(token);\n  }\n}\n"],"mappings":";;;AAKA;AACA;AANA,AASO,IAAK,YAAL,kBAAK,eAAL;AACL,wBAAQ;AACR,4BAAY;AACZ,sBAAM;AACN,6BAAa;AACb,wBAAQ;AALE;AAAA;AASL,IAAK,gBAAL,kBAAK,mBAAL;AACL,4BAAQ;AACR,4BAAQ;AACR,+BAAW;AACX,kCAAc;AAJJ;AAAA;AAgBZ,IAAM,gBAAgB,CAAC,YAA+B;AACpD,QAAM,QAAQ,QAAQ,SAAS,QAAQ,IAAI;AAC3C,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,UAAU,yBAAyB;AAAA,EAC/C;AAEA,SAAO;AACT;AAEA,IAAM,gBAAgB,CAAC,YAAgD;AACrE,MAAI;AACJ,MAAI,QAAQ,WAAW;AACrB,UAAM,QAAQ;AAAA,EAChB,WAAW,QAAQ,aAAa;AAC9B,UAAM,GAAG,aAAa,QAAQ,WAAW;AAAA,EAC3C,WAAW,QAAQ,IAAI,iBAAiB;AACtC,UAAM,OAAO,KAAK,QAAQ,IAAI,iBAAiB,QAAQ;AAAA,EACzD;AAEA,MAAI,OAAO,SAAS,GAAG,GAAG;AACxB,WAAO;AAAA,EACT;AAEA,MAAI,KAAK;AACP,UAAM,CAAC,aAAa,IAAI,SAAS,EAAE,MAAM,IAAI;AAC7C,QAAI,cAAc,mCAAmC;AACnD,aAAO;AAAA,IACT;AAEA,QAAI;AACF,aAAO,OAAO,KAAK,KAAK,QAAQ;AAAA,IAClC,SAAS,KAAP;AACA,YAAM,IAAI,UACR,kFACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,IAAI,UAAU,yBAAyB;AAC/C;AAUO,IAAM,MAAN,MAAU;AAAA,EAoBf,OAAO,KAAK,YAAoB,UAA6B,CAAC,GAAG;AAC/D,YAAQ,YACN,sFACA,mBACF;AACA,WAAO,KAAK,eAAe,YAAY,OAAO;AAAA,EAChD;AAAA,EAkBA,OAAO,eAAe,YAAoB,UAA6B,CAAC,GAAG;AACzE,UAAM,OAAO;AAAA,MACX,MAAM;AAAA,MACN,YAAY;AAAA,MACZ,QAAQ,CAAC;AAAA,MACT,GAAG;AAAA,IACL;AAEA,UAAM,QAAQ,cAAc,OAAO;AACnC,UAAM,YAAY,cAAc,OAAO;AAIvC,UAAM,YAAY,UAAU,KAAK;AACjC,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,MAAM,2BAA2B,KAAK,MAAM;AAAA,IACxD;AAEA,UAAM,eAAgC;AAAA,MACpC,OAAO;AAAA,MACP,SAAS;AAAA,MACT,UAAU;AAAA,MACV,WAAW,KAAK;AAAA,MAChB,aAAa;AAAA,MACb,WAAW;AAAA,IACb;AAEA,WAAO,IAAI,KAAK,KAAK,QAAQ,WAAW,YAAY;AAAA,EACtD;AAAA,EAgBA,OAAO,YAAY,SAAiB,UAA6B,CAAC,GAAG;AACnE,UAAM,OAAO;AAAA,MACX,YAAY;AAAA,MACZ,QAAQ,CAAC;AAAA,MACT,GAAG;AAAA,IACL;AAEA,UAAM,QAAQ,cAAc,OAAO;AACnC,UAAM,YAAY,cAAc,OAAO;AAEvC,UAAM,eAAgC;AAAA,MACpC,OAAO;AAAA,MACP,SAAS;AAAA,MACT,UAAU;AAAA,MACV,WAAW,KAAK;AAAA,MAChB,aAAa;AAAA,MACb,WAAW;AAAA,IACb;AAEA,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,UAAU,8BAA8B;AAAA,IACpD;AAEA,WAAO,IAAI,KAAK,KAAK,QAAQ,WAAW,YAAY;AAAA,EACtD;AAAA,EAmBA,OAAO,iBAAiB,IAAY,UAA6B,CAAC,GAAG;AACnE,UAAM,OAAO;AAAA,MACX,MAAM;AAAA,MACN,YAAY;AAAA,MACZ,QAAQ,CAAC;AAAA,MACT,GAAG;AAAA,IACL;AAEA,UAAM,QAAQ,cAAc,OAAO;AACnC,UAAM,YAAY,cAAc,OAAO;AAIvC,UAAM,YAAY,cAAc,KAAK;AACrC,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,MAAM,2BAA2B,KAAK,MAAM;AAAA,IACxD;AAEA,UAAM,eAAgC;AAAA,MACpC,OAAO;AAAA,MACP,SAAS;AAAA,MACT,UAAU;AAAA,MACV,WAAW,KAAK;AAAA,MAChB,aAAa;AAAA,MACb,WAAW;AAAA,IACb;AAEA,WAAO,IAAI,KAAK,KAAK,QAAQ,WAAW,YAAY;AAAA,EACtD;AAAA,EAgBA,OAAO,OAAO,OAAe;AAC3B,WAAO,IAAI,OAAO,KAAK;AAAA,EACzB;AACF;","names":[]}