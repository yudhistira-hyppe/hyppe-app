{"version":3,"sources":["../src/base.ts","../src/version.ts","../src/video/resources/assets.ts","../src/video/resources/liveStreams.ts","../src/video/resources/playbackIds.ts","../src/video/resources/uploads.ts","../src/video/resources/signingKeys.ts","../src/video/resources/deliveryUsage.ts","../src/video/resources/playbackRestrictions.ts","../src/video/resources/spaces.ts","../src/video/resources/transcriptionVocabularies.ts","../src/video/video.ts","../src/data/resources/errors.ts","../src/data/resources/exports.ts","../src/data/resources/filters.ts","../src/data/resources/dimensions.ts","../src/data/resources/incidents.ts","../src/data/resources/metrics.ts","../src/data/resources/real_time.ts","../src/data/resources/monitoring.ts","../src/data/resources/video_views.ts","../src/data/data.ts","../src/webhooks/resources/verify_header.ts","../src/webhooks/webhooks.ts","../src/utils/jwt.ts","../src/mux.ts"],"sourcesContent":["/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_config\", \"_tokenId\", \"_tokenSecret\"] }] */\n\nimport Axios, { AxiosInstance } from 'axios';\nimport EventEmitter from 'events';\n\nimport { RequestOptions, RequestParams } from './RequestOptions.js';\nimport { VERSION } from './version.js';\n\n/**\n * Mux Base Class - Simple base class to be extended by all child modules.\n *\n * @ignore\n * @property {string} tokenId - The ID for the access token.\n * @property {string} tokenSecret - The secret for the access token.\n * @property {object} config - The configuration for the Base object.\n * @property {Object} requestOptions - The HTTP request options for Mux Assets\n * @property {string} requestOptions.auth.username - HTTP basic auth username (access token)\n * @property {string} requestOptions.auth.password - HTTP basic auth password (secret)\n *\n */\nexport class Base extends EventEmitter {\n  readonly http: AxiosInstance;\n\n  private _tokenId!: string;\n  private _tokenSecret!: string;\n  private _config!: RequestOptions;\n\n  constructor(muxBase: Base);\n  constructor(requestOptions: RequestOptions);\n  constructor(tokenId: string, tokenSecret: string);\n  constructor(tokenId: string, tokenSecret: string, config: RequestOptions);\n  constructor(\n    tokenIdOrOptionsOrBase: string | RequestOptions | Base,\n    tokenSecret?: string,\n    config?: RequestOptions\n  ) {\n    super();\n\n    if (tokenIdOrOptionsOrBase instanceof Base) {\n      // we could do this with Object.assign but I'd rather we be really explicit about what we copy.\n      this.config = tokenIdOrOptionsOrBase._config;\n      this._tokenId = tokenIdOrOptionsOrBase._tokenId;\n      this._tokenSecret = tokenIdOrOptionsOrBase._tokenSecret;\n\n      this.http = tokenIdOrOptionsOrBase.http;\n    } else {\n      if (\n        typeof tokenIdOrOptionsOrBase === 'object' &&\n        !(tokenIdOrOptionsOrBase instanceof Base)\n      ) {\n        this.config = tokenIdOrOptionsOrBase;\n        this.tokenId = undefined;\n        this.tokenSecret = undefined;\n      } else {\n        // without 'as' this complains of Base | string typing, but we have ruled out the Base case implicitly\n        this.tokenId = tokenIdOrOptionsOrBase as string;\n        this.tokenSecret = tokenSecret;\n        this.config = config ?? {};\n      }\n\n      const request: RequestParams = {\n        baseURL: this.config.baseUrl,\n        headers: {\n          'User-Agent': `Mux Node | ${VERSION}`,\n          'Content-Type': 'application/json',\n          Accept: 'application/json',\n        },\n        withCredentials: false,\n        auth: {\n          username: this._tokenId,\n          password: this._tokenSecret,\n        },\n      };\n\n      if (this.config.platform?.name) {\n        if (this.config.platform?.name?.includes('|')) {\n          throw new Error('Platform name cannot contain a \"|\" value.');\n        }\n\n        if (this.config.platform?.version?.includes('|')) {\n          throw new Error('Platform version cannot contain a \"|\" value.');\n        }\n\n        request.headers[\n          'x-source-platform'\n        ] = `${this.config.platform?.name} | ${this.config.platform?.version}`;\n      }\n\n      this.http = Axios.create(request);\n\n      this.http.interceptors.request.use((req: any) => {\n        this.emit('request', req);\n\n        return req;\n      });\n\n      this.http.interceptors.response.use(\n        (res: any) => {\n          this.emit('response', res);\n          if (res.config.url && this.isVideoUrl(res.config.url)) {\n            return res.data && res.data.data;\n          }\n\n          return res.data;\n        },\n        (errorRes: any) =>\n          Promise.reject(\n            (errorRes.response && errorRes.response.data.error) || errorRes\n          )\n      );\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isVideoUrl(url: string) {\n    return url.startsWith(`/video/v1/`);\n  }\n\n  set config(options: RequestOptions) {\n    this._config = {\n      baseUrl: 'https://api.mux.com',\n      ...options,\n    };\n  }\n\n  get config() {\n    return this._config;\n  }\n\n  set tokenId(token: string | undefined) {\n    const v = token || process.env.MUX_TOKEN_ID;\n    if (!v || v.length === 0) {\n      throw new Error('API Access Token must be provided.');\n    }\n\n    this._tokenId = v;\n  }\n\n  get tokenId() {\n    return this._tokenId;\n  }\n\n  set tokenSecret(secret: string | undefined) {\n    const v = secret || process.env.MUX_TOKEN_SECRET;\n    if (!v || v.length === 0) {\n      throw new Error('API secret key must be provided');\n    }\n\n    this._tokenSecret = v;\n  }\n\n  get tokenSecret() {\n    return this._tokenSecret;\n  }\n}\n","export const VERSION = '7.3.0' as const;\n","/*!\n * Mux Assets\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport {\n  Asset,\n  CreateAssetParams,\n  CreatePlaybackIdParams,\n  CreateTrackParams,\n  InputInfo,\n  ListAssetParams,\n  PlaybackId,\n  Track,\n  UpdateAssetParams,\n  UpdateMasterAccessParams,\n  UpdateMp4SupportParams,\n} from '../domain.js';\n\n/**\n * @private Base asset path for the Mux API\n * */\nconst PATH = '/video/v1/assets';\n\n/**\n * @private\n * Build the base asset path for the Mux API\n * */\nconst buildBasePath = (assetId: string) => `${PATH}/${assetId}`;\n\n/**\n * Assets Class - Provides access to the Mux Video Assets API\n *\n * @example\n * const { Video } = new Mux(accessToken, secret);\n *\n * // Create an asset\n * Video.Assets.create({input: 'https://storage.googleapis.com/muxdemofiles/mux-video-intro.mp4'});\n */\nexport class Assets extends Base {\n  /**\n   * Creates a Mux asset with the specified JSON parameters\n   * @param {Object} params - Asset JSON parameters (e.g input)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Create an asset\n   * Video.Assets.create({input: 'https://storage.googleapis.com/muxdemofiles/mux-video-intro.mp4'});\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/create-asset\n   */\n  create(params: CreateAssetParams): Promise<Asset> {\n    if (!params) {\n      return Promise.reject(\n        new Error('Params are required for creating an asset')\n      );\n    }\n\n    return this.http.post(PATH, params);\n  }\n\n  /**\n   * Updates an existing asset with new parameters.\n   *\n   * @param {string} assetId - the ID of the asset\n   * @param {Object} params - Asset JSON parameters (e.g passthrough)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   */\n  async update(assetId: string, params: UpdateAssetParams): Promise<Asset> {\n    if (!assetId || !params) {\n      throw new Error('assetId and params are required.');\n    }\n\n    return this.http.patch(buildBasePath(assetId), params);\n  }\n\n  /**\n   * Deletes a Mux asset\n   * @param {string} assetId - The ID for the asset intended for deletion\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Delete an asset\n   * Video.Assets.del(assetId);\n   *\n   * @see hhttps://docs.mux.com/api-reference/video#operation/delete-asset\n   */\n  del(assetId: string): Promise<any> {\n    if (!assetId) {\n      return Promise.reject(\n        new Error('An asset ID is required to delete an asset')\n      );\n    }\n    return this.http.delete(buildBasePath(assetId));\n  }\n\n  /**\n   * Get an asset\n   * @param {string} assetId - The ID for the asset\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Get an asset\n   * Video.Assets.get(assetId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-asset\n   */\n  get(assetId: string): Promise<Asset> {\n    if (!assetId) {\n      return Promise.reject(\n        new Error('An asset ID is required to get an asset')\n      );\n    }\n    return this.http.get(buildBasePath(assetId));\n  }\n\n  /**\n   * Get input info for an asset\n   * @param {string} assetId - The ID for the asset\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Get input info for an asset\n   * Video.Assets.inputInfo(assetId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-asset-input-info\n   */\n  inputInfo(assetId: string): Promise<Array<InputInfo>> {\n    if (!assetId) {\n      return Promise.reject(\n        new Error('An asset ID is required to get input-info')\n      );\n    }\n    return this.http.get(`${buildBasePath(assetId)}/input-info`);\n  }\n\n  /**\n   * List all assets for a Mux Environment (tied to your access token)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // List all assets for a Mux Environment\n   * Video.Assets.list();\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/list-assets\n   */\n  list(params: ListAssetParams): Promise<Array<Asset>> {\n    return this.http.get(PATH, { params });\n  }\n\n  /**\n   * Return an asset playback id\n   * @param {string} assetId - The ID for the asset\n   * @param {string} playbackId - The ID for the playbackId\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Retrieve an asset playbackId\n   * Video.Assets.playbackId(assetId, playbackId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-asset-playback-id\n   */\n  playbackId(assetId: string, playbackId: string): Promise<PlaybackId> {\n    if (!assetId) {\n      return Promise.reject(new Error('An asset ID is required'));\n    }\n\n    if (!playbackId) {\n      return Promise.reject(new Error('A playback ID is required'));\n    }\n    return this.http.get(\n      `${buildBasePath(assetId)}/playback-ids/${playbackId}`\n    );\n  }\n\n  /**\n   * Create an asset playback id\n   * @param {string} assetId - The ID for the asset\n   * @param {Object} params - Asset JSON parameters (e.g playback_policy)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Create an asset playback ID\n   * Video.Assets.createPlaybackId(assetId, { policy: 'public' });\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/create-asset-playback-id\n   */\n  createPlaybackId(\n    assetId: string,\n    params: CreatePlaybackIdParams\n  ): Promise<PlaybackId> {\n    if (!assetId) {\n      return Promise.reject(new Error('An asset ID is required'));\n    }\n\n    if (!params) {\n      return Promise.reject(new Error('Playback ID params are required'));\n    }\n    return this.http.post(`${buildBasePath(assetId)}/playback-ids`, params);\n  }\n\n  /**\n   * Delete an asset playback ID\n   * @param {string} assetId - The ID for the asset\n   * @param {string} playbackId - The ID for the asset playback ID to delete\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Delete an asset playback ID\n   * Video.Assets.deletePlaybackId(assetId, { policy: 'public' });\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/delete-asset-playback-id\n   */\n  deletePlaybackId(assetId: string, playbackId: string): Promise<any> {\n    if (!assetId) {\n      return Promise.reject(new Error('An asset ID is required'));\n    }\n\n    if (!playbackId) {\n      return Promise.reject(new Error('A playback ID is required'));\n    }\n    return this.http.delete(\n      `${buildBasePath(assetId)}/playback-ids/${playbackId}`\n    );\n  }\n\n  /**\n   * Create a subtitle text track\n   * @param {string} assetId - The ID for the asset\n   * @param {Object} params - subtitle text track JSON parameters\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Create an asset text track\n   * Video.Assets.createTrack(assetId, {\n   *   url: \"https://example.com/myVIdeo_en.srt\",\n   *   type: \"text\",\n   *   text_type: \"subtitles\",\n   *   language_code: \"en-US\",\n   * });\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/create-asset-track\n   */\n  createTrack(assetId: string, params: CreateTrackParams): Promise<Track> {\n    if (!assetId) {\n      return Promise.reject(new Error('An asset ID is required'));\n    }\n\n    if (!params) {\n      return Promise.reject(new Error('Text track params are required'));\n    }\n    return this.http.post(`${buildBasePath(assetId)}/tracks`, params);\n  }\n\n  /**\n   * Delete an asset text track\n   * @param {string} assetId - The ID for the asset\n   * @param {string} trackId - The ID for the asset text track to delete\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Delete an asset text track\n   * Video.Assets.deleteTrack(assetId, trackId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/delete-asset-track\n   */\n  deleteTrack(assetId: string, trackId: string): Promise<any> {\n    if (!assetId) {\n      return Promise.reject(new Error('An asset ID is required'));\n    }\n\n    if (!trackId) {\n      return Promise.reject(new Error('A track ID is required'));\n    }\n    return this.http.delete(`${buildBasePath(assetId)}/tracks/${trackId}`);\n  }\n\n  /**\n   * Update mp4 support for an asset\n   * @param {Object} params - mp4 support JSON parameters\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Updates mp4 support for an asset\n   * Video.Assets.updateMp4Support(assetId, {mp4_support: \"standard\"});\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/update-asset-mp4-support\n   */\n  updateMp4Support(\n    assetId: string,\n    params: UpdateMp4SupportParams\n  ): Promise<Asset> {\n    if (!assetId) {\n      return Promise.reject(new Error('An asset ID is required'));\n    }\n\n    if (!(params && params.mp4_support)) {\n      return Promise.reject(new Error('params.mp4_support is required'));\n    }\n    return this.http.put(`${buildBasePath(assetId)}/mp4-support`, params);\n  }\n\n  /**\n   * Update master access for an asset\n   * @param {Object} params - master access JSON parameters\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Update master access for an asset\n   * Video.Assets.updateMasterAccess(assetId, {master_access: \"temporary\"});\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/update-asset-master-access\n   */\n  updateMasterAccess(\n    assetId: string,\n    params: UpdateMasterAccessParams\n  ): Promise<Asset> {\n    if (!assetId) {\n      return Promise.reject(new Error('An asset ID is required'));\n    }\n\n    if (!(params && params.master_access)) {\n      return Promise.reject(new Error('params.master_access is required'));\n    }\n    return this.http.put(`${buildBasePath(assetId)}/master-access`, params);\n  }\n}\n","/*!\n * Mux Live Streams\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport {\n  CreateLiveStreamParams,\n  CreatePlaybackIdParams,\n  ListLiveStreamParams,\n  LiveStream,\n  PlaybackId,\n  SimulcastTarget,\n  SimulcastTargetParams,\n  UpdateLiveStreamEmbeddedSubtitlesParams,\n  UpdateLiveStreamGeneratedSubtitlesParams,\n  UpdateLiveStreamParams,\n} from '../domain.js';\n\n/**\n * @private Base live stream path for the Mux API\n * */\nconst PATH = '/video/v1/live-streams';\n\n/**\n * @private\n * Build the base live stream path for the Mux API\n * */\nconst buildBasePath = (liveStreamId: string) => `${PATH}/${liveStreamId}`;\n\n/**\n * Live Streams Class - Provides access to the Mux Video Live Streams API\n *\n * @extends Base\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Video } = muxClient;\n *\n * // Create a live stream\n * Video.LiveStreams.create({\n *  playback_policy: 'public',\n *  new_asset_settings: { playback_policy: 'public' }\n * });\n */\nexport class LiveStreams extends Base {\n  /**\n   * Creates a Mux live stream with the specified JSON parameters\n   * @param {Object} params - Live Stream JSON parameters\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Video } = muxClient;\n   *\n   * // Create a live stream\n   * Video.LiveStreams.create({\n   *  playback_policy: 'public',\n   *  new_asset_settings: { playback_policy: 'public' }\n   * });\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream\n   */\n  create(params: CreateLiveStreamParams): Promise<LiveStream> {\n    return this.http.post(PATH, params);\n  }\n\n  /**\n   * Updates an existing livestream with new parameters.\n   *\n   * @param {string} liveStreamId - the ID of the live stream\n   * @param {Object} params - Live Stream JSON parameters (e.g playback_policy)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   */\n  async update(\n    liveStreamId: string,\n    params: UpdateLiveStreamParams\n  ): Promise<LiveStream> {\n    if (!liveStreamId || !params) {\n      throw new Error('assetId and params are required.');\n    }\n\n    return this.http.patch(buildBasePath(liveStreamId), params);\n  }\n\n  /**\n   * Deletes a Mux Live Stream\n   * @param {string} liveStreamId - The ID for the live stream intended for deletion\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Delete a mux live stream\n   * Video.LiveStreams.del(liveStreamId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream\n   */\n  del(liveStreamId: string): Promise<any> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to delete a live stream')\n      );\n    }\n    return this.http.delete(buildBasePath(liveStreamId));\n  }\n\n  /**\n   * Get an Live Stream\n   * @param {string} liveStreamId - The ID for the live stream\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Get a live stream\n   * Video.LiveStreams.get(liveStreamId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-live-stream\n   */\n  get(liveStreamId: string): Promise<LiveStream> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to get a live stream')\n      );\n    }\n    return this.http.get(buildBasePath(liveStreamId));\n  }\n\n  /**\n   * List all live streams for a Mux Environment (tied to your access token)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // List all live streams for a Mux Environment\n   * Video.LiveStreams.list();\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/list-live-streams\n   */\n  list(params: ListLiveStreamParams): Promise<Array<LiveStream>> {\n    return this.http.get(PATH, { params });\n  }\n\n  /**\n   * Signal a live stream is finished\n   * @param {string} liveStreamId - The ID for the live stream\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Signal a live stream is finished\n   * Video.LiveStreams.signalComplete(liveStreamId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/signal-live-stream-complete\n   */\n  signalComplete(liveStreamId: string): Promise<any> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to signal a stream is complete')\n      );\n    }\n    return this.http.put(`${buildBasePath(liveStreamId)}/complete`);\n  }\n\n  /**\n   * Reset a stream key\n   * @param {string} liveStreamId - The ID for the live stream\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Reset a live stream key if you want to immediately stop the current stream key\n   * // from working and create a new stream key that can be used for future broadcasts.\n   * Video.LiveStreams.resetStreamKey(liveStreamId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/reset-stream-key\n   */\n  resetStreamKey(liveStreamId: string): Promise<LiveStream> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to reset a live stream key')\n      );\n    }\n    return this.http.post(`${buildBasePath(liveStreamId)}/reset-stream-key`);\n  }\n\n  /**\n   * Create a live stream playback id\n   * @param {string} liveStreamId - The ID for the live stream\n   * @param {Object} params - Live Stream JSON parameters (e.g playback_policy)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Create a live stream playback ID\n   * Video.LiveStreams.createPlaybackId(liveStreamId, { policy: 'public' });\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream-playback-id\n   */\n  createPlaybackId(\n    liveStreamId: string,\n    params: CreatePlaybackIdParams\n  ): Promise<PlaybackId> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error(\n          'A live stream ID is required to create a live stream playback ID'\n        )\n      );\n    }\n\n    if (!params) {\n      return Promise.reject(\n        new Error(\n          'A playback policy is required to create a live stream playback ID'\n        )\n      );\n    }\n    return this.http.post(\n      `${buildBasePath(liveStreamId)}/playback-ids`,\n      params\n    );\n  }\n\n  /**\n   * Delete a live stream playback ID\n   * @param {string} liveStreamId - The ID for the live stream\n   * @param {string} playbackId - The ID for the live stream playback ID to delete\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Delete a live stream playback ID\n   * Video.LiveStreams.deletePlaybackId(liveStreamId, { policy: 'public' });\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream-playback-id\n   */\n  deletePlaybackId(liveStreamId: string, playbackId: string): Promise<any> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error(\n          'A live stream ID is required to delete a live stream playback ID'\n        )\n      );\n    }\n\n    if (!playbackId) {\n      return Promise.reject(\n        new Error(\n          'A live stream playback ID is required to delete a live stream playback ID'\n        )\n      );\n    }\n    return this.http.delete(\n      `${buildBasePath(liveStreamId)}/playback-ids/${playbackId}`\n    );\n  }\n\n  /**\n   * Return a live stream playback id\n   * @param {string} liveStreamId - The ID for the live stream\n   * @param {string} playbackId - The ID for the playbackId\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-asset-playback-id\n   */\n  playbackId(liveStreamId: string, playbackId: string): Promise<PlaybackId> {\n    if (!liveStreamId) {\n      return Promise.reject(new Error('A live stream ID is required'));\n    }\n\n    if (!playbackId) {\n      return Promise.reject(new Error('A playback ID is required'));\n    }\n    return this.http.get(\n      `${buildBasePath(liveStreamId)}/playback-ids/${playbackId}`\n    );\n  }\n\n  /**\n   * Create a simulcast target\n   * @param {string} liveStreamId - The ID for the live stream\n   * @param {Object} params - Simulcast Target JSON parameters (e.g url and stream_key)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Create a live simulcast target\n   * Video.LiveStreams.createSimulcastTarget(liveStreamId, {url: 'rtmp://live.example.com/app', stream_key: 'difvbfgi', passthrough: 'Example Live Streaming service'});\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream-simulcast-target\n   */\n  createSimulcastTarget(\n    liveStreamId: string,\n    params: SimulcastTargetParams\n  ): Promise<SimulcastTarget> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to create a simulcast target')\n      );\n    }\n\n    if (!(params && params.url)) {\n      return Promise.reject(\n        new Error('A url is required to create a simulcast target')\n      );\n    }\n    return this.http.post(\n      `${buildBasePath(liveStreamId)}/simulcast-targets`,\n      params\n    );\n  }\n\n  /**\n   * Get a simulcast target\n   * @param {string} liveStreamId - The ID for the live stream\n   * @param {string} simulcastTargetId - The ID for the simulcast target to delete\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Get a live simulcast target\n   * Video.LiveStreams.getSimulcastTarget(liveStreamId, simulcastTargetId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-live-stream-simulcast-target\n   */\n  getSimulcastTarget(\n    liveStreamId: string,\n    simulcastTargetId: string\n  ): Promise<SimulcastTarget> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to get a simulcast target')\n      );\n    }\n\n    if (!simulcastTargetId) {\n      return Promise.reject(\n        new Error('A simulcast target ID is required to get a simulcast target')\n      );\n    }\n    return this.http.get(\n      `${buildBasePath(liveStreamId)}/simulcast-targets/${simulcastTargetId}`\n    );\n  }\n\n  /**\n   * Delete a simulcast target\n   * @param {string} liveStreamId - The ID for the live stream\n   * @param {string} simulcastTargetId - The ID for the simulcast target to delete\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Delete a simulcast target\n   * Video.LiveStreams.deleteSimulcastTarget(liveStreamId, simulcastTargetId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream-simulcast-target\n   */\n  deleteSimulcastTarget(\n    liveStreamId: string,\n    simulcastTargetId: string\n  ): Promise<any> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to delete a simulcast target')\n      );\n    }\n\n    if (!simulcastTargetId) {\n      return Promise.reject(\n        new Error(\n          'A simulcast target ID is required to delete a simulcast target'\n        )\n      );\n    }\n    return this.http.delete(\n      `${buildBasePath(liveStreamId)}/simulcast-targets/${simulcastTargetId}`\n    );\n  }\n\n  /**\n   * Configures a live stream to receive embedded closed captions.\n   * The resulting Asset's subtitle text track will have `closed_captions: true` set.\n   * @param {string} liveStreamId - The ID for the live stream\n   * @param {string} params - Embedded subtitles parameters.\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   */\n  async updateEmbeddedSubtitles(\n    liveStreamId: string,\n    params: UpdateLiveStreamEmbeddedSubtitlesParams\n  ): Promise<LiveStream> {\n    if (!liveStreamId || !params) {\n      throw new Error('liveStreamId and params are required.');\n    }\n\n    return this.http.put(\n      `${buildBasePath(liveStreamId)}/embedded-subtitles`,\n      params\n    );\n  }\n\n  /**\n   * Configures a live stream to receive generated closed captions.\n   * @param {string} liveStreamId - The ID for the live stream\n   * @param {string} params - Generated subtitles parameters.\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   */\n  async updateGeneratedSubtitles(\n    liveStreamId: string,\n    params: UpdateLiveStreamGeneratedSubtitlesParams\n  ): Promise<LiveStream> {\n    if (!liveStreamId || !params) {\n      throw new Error('liveStreamId and params are required.');\n    }\n\n    return this.http.put(\n      `${buildBasePath(liveStreamId)}/generated-subtitles`,\n      params\n    );\n  }\n\n  /**\n   * Disable a Live Stream\n   * @param {string} liveStreamId - The ID for the live stream\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Disable a live stream\n   * Video.LiveStreams.disable(liveStreamId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/disable-live-stream\n   */\n  disable(liveStreamId: string): Promise<any> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to disable a live stream')\n      );\n    }\n    return this.http.put(`${buildBasePath(liveStreamId)}/disable`);\n  }\n\n  /**\n   * Enable a Live Stream\n   * @param {string} liveStreamId - The ID for the live stream\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Enable a Live Stream\n   * Video.LiveStreams.enable(liveStreamId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/enable-live-stream\n   */\n  enable(liveStreamId: string): Promise<any> {\n    if (!liveStreamId) {\n      return Promise.reject(\n        new Error('A live stream ID is required to enable a live stream')\n      );\n    }\n    return this.http.put(`${buildBasePath(liveStreamId)}/enable`);\n  }\n}\n","/*!\n * Mux Assets\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport { PlaybackIdentifier } from '../domain.js';\n\n/**\n * @private Base playback ID path for the Mux API\n * */\nconst PATH = '/video/v1/playback-ids';\n\n/**\n * @private\n * Build the base playback ID path for the Mux API\n * */\nconst buildBasePath = (playbackId: string) => `${PATH}/${playbackId}`;\n\n/**\n * PlaybackIds Class - Provides access to the Mux Playback ID API\n *\n * @example\n * const { Video } = new Mux(accessToken, secret);\n *\n * // Retrieve an Asset or Live Stream  identifier associated with a Playback ID\n * Video.PlaybackIds.get(playbackId);\n */\nexport class PlaybackIds extends Base {\n  /**\n   * Retrieve an Asset or Live Stream  identifier associated with a Playback ID\n   * @param {string} playbackId - The ID for playback\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Retrieve an Asset or Live Stream identifier associated with a Playback ID\n   * Video.PlaybackIds.get(playbackId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-asset-or-livestream-id\n   */\n  get(playbackId: string): Promise<PlaybackIdentifier> {\n    if (!playbackId) {\n      return Promise.reject(\n        new Error(\n          'An playback ID is required to get an asset or live stream identifier'\n        )\n      );\n    }\n    return this.http.get(buildBasePath(playbackId));\n  }\n}\n","/*!\n * Mux Assets\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport { CreateUploadParams, ListUploadParams, Upload } from '../domain.js';\n\n/**\n * @private Base asset path for the Mux API\n * */\nconst PATH = '/video/v1/uploads';\n\n/**\n * @private\n * Build the base asset path for the Mux API\n * */\nconst buildBasePath = (uploadId: string) => `${PATH}/${uploadId}`;\n\n/**\n * Uploads Class - Provides access to the Mux Video Uploads API\n *\n * @example\n * const { Video } = new Mux(accessToken, secret);\n *\n * // Create an upload\n * Video.Uploads.create({ new_asset_settings: { playback_policy: 'public' } });\n */\nexport class Uploads extends Base {\n  /**\n   * Creates a direct upload with the specified JSON parameters\n   * @extends Base\n   * @param {Object} params - Upload JSON parameters (e.g timeout)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Video } = muxClient;\n   *\n   * // Create a new upload\n   * const upload = await Video.Uploads.create({new_asset_settings: {playback_policy: 'public'}});\n   * // Now push a file to the URL returned.\n   * fs.createReadStream(pathToFile).pipe(request.put(upload.url))\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/create-direct-upload\n   */\n  create(params: CreateUploadParams): Promise<Upload> {\n    if (!params) {\n      return Promise.reject(\n        new Error('Params are required for creating a direct upload')\n      );\n    }\n\n    return this.http.post(PATH, params);\n  }\n\n  /**\n   * Cancels an upload\n   * @param {string} uploadId - The ID for the upload intended for cancellation\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Cancels an upload\n   * Video.Uploads.cancel(uploadId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/cancel-direct-upload\n   */\n  cancel(uploadId: string): Promise<any> {\n    if (!uploadId) {\n      return Promise.reject(new Error('An upload ID is required'));\n    }\n    return this.http.put(`${buildBasePath(uploadId)}/cancel`);\n  }\n\n  /**\n   * Get an upload\n   * @param {string} uploadId - The ID for the upload\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Get an upload\n   * Video.Uploads.get(uploadId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-direct-upload\n   */\n  get(uploadId: string): Promise<Upload> {\n    if (!uploadId) {\n      return Promise.reject(\n        new Error('An upload ID is required to get an asset')\n      );\n    }\n    return this.http.get(buildBasePath(uploadId));\n  }\n\n  /**\n   * List all uploads\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // List all uploads\n   * Video.Uploads.list();\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/list-direct-uploads\n   */\n  list(params: ListUploadParams): Promise<Array<Upload>> {\n    return this.http.get(PATH, { params });\n  }\n}\n","/*!\n * Mux Signing Keys\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport { SigningKey } from '../domain.js';\n\n/**\n * @private Base signing-key path for the Mux API\n * */\nconst PATH = '/video/v1/signing-keys';\n\n/**\n * @private\n * Build the base asset path for the Mux API\n * */\nconst buildBasePath = (keyId: string) => `${PATH}/${keyId}`;\n\n/**\n * Signing Key Class - Provides access to the Mux Video Signing Key API\n *\n * @example\n * const { Video } = new Mux(accessToken, secret);\n *\n * // Create a new signing key\n * Video.SigningKeys.create();\n */\nexport class SigningKeys extends Base {\n  /**\n   * Creates a new Signing Key that can be used with the JWT module to sign URLs.\n   * @extends Base\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Video } = muxClient;\n   *\n   * // Create a new signing key\n   * Video.SigningKeys.create();\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/create-url-signing-key\n   */\n  create(): Promise<SigningKey> {\n    return this.http.post(PATH, {});\n  }\n\n  /**\n   * Get a signing key. *Note* The private key is _not_ returned.\n   * @param {string} keyId - The ID for the signing key\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Get a signing key\n   * Video.SigningKeys.get(keyId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/get-url-signing-key\n   */\n  get(keyId: string): Promise<SigningKey> {\n    if (!keyId) {\n      return Promise.reject(new Error('An signing key ID is required.'));\n    }\n    return this.http.get(buildBasePath(keyId));\n  }\n\n  /**\n   * Delete a signing key\n   * @param {string} keyId - The ID for the signing key\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // Delete a signing key\n   * Video.SigningKeys.del(keyId);\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/delete-url-signing-key\n   */\n  del(keyId: string): Promise<any> {\n    if (!keyId) {\n      return Promise.reject(new Error('An signing key ID is required.'));\n    }\n    return this.http.delete(buildBasePath(keyId));\n  }\n\n  /**\n   * List signing keys\n   * @param {string} keyId - The ID for the signing key\n   * @param {object} params - Object to include as query params\n   * @param {number} params.limit - Number of signing keys to return in the response\n   * @param {number} params.page - Page of signing keys to return (limit * page)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // List all signing keys\n   * Video.SigningKeys.list();\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/list-url-signing-keys\n   */\n  list(params: {} = {}): Promise<Array<SigningKey>> {\n    return this.http.get(PATH, { params });\n  }\n}\n","/*!\n * Mux DeliveryUsage\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport { DeliveryReport, ListDeliveryUsageParams } from '../domain.js';\n\n/**\n * @private Base delivery usage path for the Mux API\n * */\nconst PATH = '/video/v1/delivery-usage';\n\n/**\n * DeliveryUsage Class - Provides access to the Mux Video Delivery Usage API\n *\n * @example\n * const { Video } = new Mux(accessToken, secret);\n *\n * // List delivery usage within a timeframe\n * Video.DeliveryUsage.list({timeframe: [1574076240, 1573471440]});\n */\nexport class DeliveryUsage extends Base {\n  /**\n   * List all delivery usage during a timeframe for a Mux Environment (tied to your access token)\n   * @param {Object} params - Request JSON parameters (e.g timeframe)\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Video } = new Mux(accessToken, secret);\n   *\n   * // List all delivery usage for a Mux Environment within a timeframe\n   * Video.DeliveryUsage.list({timeframe: [1574076240, 1573471440]});\n   *\n   * @see https://docs.mux.com/api-reference/video#operation/list-delivery-usage\n   */\n  list(params: ListDeliveryUsageParams): Promise<Array<DeliveryReport>> {\n    return this.http.get(PATH, { params });\n  }\n}\n","import { Base } from '../../base.js';\nimport {\n  CreatePlaybackRestrictionParams,\n  PlaybackRestriction,\n  ReferrerDomainRestriction,\n} from '../domain.js';\n\n/**\n * @private Base playback restriction path for the Mux API\n * */\nconst PATH = '/video/v1/playback-restrictions';\n\n/**\n * @private\n * Build the base playback restriction path for the Mux API\n * */\nconst buildBasePath = (restrictionId: string) => `${PATH}/${restrictionId}`;\n\nexport class PlaybackRestrictions extends Base {\n  create(\n    restriction: CreatePlaybackRestrictionParams\n  ): Promise<PlaybackRestriction> {\n    return this.http.post(PATH, restriction);\n  }\n\n  list(): Promise<Array<PlaybackRestriction>> {\n    return this.http.get(PATH);\n  }\n\n  get(restrictionId: string): Promise<PlaybackRestriction> {\n    return this.http.get(buildBasePath(restrictionId));\n  }\n\n  delete(restrictionId: string): Promise<PlaybackRestriction> {\n    return this.http.delete(buildBasePath(restrictionId));\n  }\n\n  putReferrer(\n    restrictionId: string,\n    referrer: ReferrerDomainRestriction\n  ): Promise<PlaybackRestriction> {\n    return this.http.put(`${buildBasePath(restrictionId)}/referrer`, referrer);\n  }\n}\n","import { Base } from '../../base.js';\nimport { RequestOptions } from '../../RequestOptions.js';\nimport {\n  Broadcast,\n  CreateBroadcastRequest,\n  CreateSpaceRequest,\n  ListSpacesRequest,\n  Space,\n} from '../domain.js';\n\nconst BASE_PATH = '/video/v1/spaces';\n\nconst SPACE_PATH = (spaceId: string) => `${BASE_PATH}/${spaceId}`;\nconst BROADCAST_PATH = (spaceId: string, broadcastId: string) =>\n  `${SPACE_PATH(spaceId)}/broadcasts/${broadcastId}`;\n\nexport class Broadcasts extends Base {\n  create(spaceId: string, request: CreateBroadcastRequest): Promise<Broadcast> {\n    return this.http.post(`${SPACE_PATH(spaceId)}/broadcasts`, request);\n  }\n\n  get(spaceId: string, broadcastId: string): Promise<Broadcast> {\n    return this.http.get(BROADCAST_PATH(spaceId, broadcastId));\n  }\n\n  delete(spaceId: string, broadcastId: string): Promise<any> {\n    return this.http.delete(BROADCAST_PATH(spaceId, broadcastId));\n  }\n\n  start(spaceId: string, broadcastId: string): Promise<any> {\n    return this.http.post(`${BROADCAST_PATH(spaceId, broadcastId)}/start`);\n  }\n\n  stop(spaceId: string, broadcastId: string): Promise<any> {\n    return this.http.post(`${BROADCAST_PATH(spaceId, broadcastId)}/stop`);\n  }\n}\n\nexport class Spaces extends Base {\n  readonly Broadcasts: Broadcasts;\n\n  constructor(base: Base);\n  constructor(config: RequestOptions);\n  constructor(accessToken: string, secret: string);\n  constructor(accessToken: string, secret: string, config: RequestOptions);\n  constructor(\n    accessTokenOrConfigOrBase: string | RequestOptions | Base,\n    secret?: string,\n    config?: RequestOptions\n  ) {\n    if (accessTokenOrConfigOrBase instanceof Base) {\n      super(accessTokenOrConfigOrBase);\n    } else if (typeof accessTokenOrConfigOrBase === 'object') {\n      super(accessTokenOrConfigOrBase);\n    } else {\n      super(accessTokenOrConfigOrBase, secret!, config ?? {});\n    }\n\n    this.Broadcasts = new Broadcasts(this);\n  }\n\n  create(req: CreateSpaceRequest): Promise<Space> {\n    return this.http.post(BASE_PATH, req);\n  }\n\n  list(params: ListSpacesRequest): Promise<Array<Space>> {\n    return this.http.get(BASE_PATH, { params });\n  }\n\n  get(spaceId: string): Promise<Space> {\n    return this.http.get(SPACE_PATH(spaceId));\n  }\n\n  delete(spaceId: string): Promise<Space> {\n    return this.http.delete(SPACE_PATH(spaceId));\n  }\n}\n","import { Base } from '../../base.js';\nimport {\n  UpsertTranscriptionVocabularyParams,\n  TranscriptionVocabulary,\n} from '../domain.js';\n\n/**\n * @private Base transcription vocabulary path for the Mux API\n * */\nconst PATH = '/video/v1/transcription-vocabularies';\n\n/**\n * @private\n * Build the base transcription vocabulary path for the Mux API\n * */\nconst buildBasePath = (transcriptionVocabularyId: string) =>\n  `${PATH}/${transcriptionVocabularyId}`;\n\nexport class TranscriptionVocabularies extends Base {\n  create(\n    transcriptionVocabulary: UpsertTranscriptionVocabularyParams\n  ): Promise<TranscriptionVocabulary> {\n    return this.http.post(PATH, transcriptionVocabulary);\n  }\n\n  list(): Promise<Array<TranscriptionVocabulary>> {\n    return this.http.get(PATH);\n  }\n\n  get(transcriptionVocabularyId: string): Promise<TranscriptionVocabulary> {\n    return this.http.get(buildBasePath(transcriptionVocabularyId));\n  }\n\n  delete(transcriptionVocabularyId: string): Promise<void> {\n    return this.http.delete(buildBasePath(transcriptionVocabularyId));\n  }\n\n  update(\n    transcriptionVocabularyId: string,\n    transcriptionVocabulary: UpsertTranscriptionVocabularyParams\n  ): Promise<TranscriptionVocabulary> {\n    return this.http.put(\n      `${buildBasePath(transcriptionVocabularyId)}`,\n      transcriptionVocabulary\n    );\n  }\n}\n","/*!\n * Mux Video\n * Copyright(c) 2022 Mux Inc.\n */\n\nimport { Base } from '../base.js';\nimport { RequestOptions } from '../RequestOptions.js';\n\nimport { Assets } from './resources/assets.js';\nimport { LiveStreams } from './resources/liveStreams.js';\nimport { PlaybackIds } from './resources/playbackIds.js';\nimport { Uploads } from './resources/uploads.js';\nimport { SigningKeys } from './resources/signingKeys.js';\nimport { DeliveryUsage } from './resources/deliveryUsage.js';\nimport { PlaybackRestrictions } from './resources/playbackRestrictions.js';\nimport { Spaces } from './resources/spaces.js';\nimport { TranscriptionVocabularies } from './resources/transcriptionVocabularies.js';\n\n/**\n * @ignore\n * @extends Base\n * Video Class - Provides access to the Mux Video API\n *\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Video } = muxClient;\n *\n * // Create an asset\n * Video.Assets.create({input: 'https://storage.googleapis.com/muxdemofiles/mux-video-intro.mp4'});\n *\n * // Create an asset playback ID\n * Video.Assets.createPlaybackId(assetId, { policy: 'public' });\n */\nexport class Video extends Base {\n  readonly Assets: Assets;\n  readonly LiveStreams: LiveStreams;\n  readonly PlaybackIds: PlaybackIds;\n  readonly PlaybackRestrictions: PlaybackRestrictions;\n  readonly Uploads: Uploads;\n  readonly SigningKeys: SigningKeys;\n  readonly DeliveryUsage: DeliveryUsage;\n  readonly Spaces: Spaces;\n  readonly TranscriptionVocabularies: TranscriptionVocabularies;\n\n  constructor(base: Base);\n  constructor(config: RequestOptions);\n  constructor(accessToken: string, secret: string, config: RequestOptions);\n  constructor(\n    accessTokenOrConfigOrBase: string | RequestOptions | Base,\n    secret?: string,\n    config?: RequestOptions\n  ) {\n    if (accessTokenOrConfigOrBase instanceof Base) {\n      super(accessTokenOrConfigOrBase);\n    } else if (typeof accessTokenOrConfigOrBase === 'object') {\n      super(accessTokenOrConfigOrBase);\n    } else {\n      super(accessTokenOrConfigOrBase, secret!, config!);\n    }\n\n    /** @type {Assets} */\n    this.Assets = new Assets(this);\n\n    /** @type {LiveStreams} */\n    this.LiveStreams = new LiveStreams(this);\n\n    /** @type {PlaybackIds} */\n    this.PlaybackIds = new PlaybackIds(this);\n\n    /** @Type {Uploads} */\n    this.Uploads = new Uploads(this);\n\n    /** @Type {SigningKeys} */\n    this.SigningKeys = new SigningKeys(this);\n\n    /** @Type {DeliveryUsage} */\n    this.DeliveryUsage = new DeliveryUsage(this);\n\n    /** @Type {PlaybackRestrictions} */\n    this.PlaybackRestrictions = new PlaybackRestrictions(this);\n\n    /** @Type {Spaces} */\n    this.Spaces = new Spaces(this);\n\n    /** @Type {TranscriptionVocabularies} */\n    this.TranscriptionVocabularies = new TranscriptionVocabularies(this);\n  }\n}\n","/*!\n * Mux Errors\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport { ErrorsListResponse, ErrorsParams } from '../domain.js';\n\n/**\n * @private Base errors path for the Mux API\n * */\nconst PATH = '/data/v1/errors';\n\n/**\n * Errors Class - Provides access to the Mux Data Errors API\n * @extends Base\n * @example\n * const { Data } = new Mux(accessToken, secret);\n *\n * // Returns a list of playback errors filtered by the windows operating system\n * Data.Errors.list({ filters: ['operating_system:windows'] });\n */\nexport class Errors extends Base {\n  /**\n   * Returns a list of playback errors\n   *\n   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Data } = new Mux(accessToken, secret);\n   *\n   * // Returns a list of playback errors filtered by the windows operating system\n   * Data.Errors.list({ filters: ['operating_system:windows'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-errors\n   */\n  list(params?: ErrorsParams): Promise<ErrorsListResponse> {\n    return this.http.get(PATH, { params });\n  }\n}\n","/*!\n * Mux Exports\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport { ExportsListResponse } from '../domain.js';\n\n/**\n * @private Base exports path for the Mux API\n * */\nconst PATH = '/data/v1/exports';\n\n/**\n * Exports Class - Provides access to the Mux Data Exports API\n *\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Data } = muxClient;\n *\n * // Lists the available video view exports along with URLs to retrieve them\n * Data.Exports.list();\n */\nexport class Exports extends Base {\n  /**\n   * Lists the available video view exports along with URLs to retrieve them\n   * @extends Base\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Lists the available video view exports along with URLs to retrieve them\n   * Data.Exports.list();\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-exports\n   */\n  list(): Promise<ExportsListResponse> {\n    return this.http.get(PATH);\n  }\n}\n","/*!\n * Mux Filters\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport { FilterGetResponse, FilterQueryParams } from '../domain.js';\n\n/**\n * @private Base filters path for the Mux API\n * */\nconst PATH = '/data/v1/filters';\n\n/**\n * Filters Class - Provides access to the Mux Data Filters API\n *\n * @extends Base\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Data } = muxClient;\n *\n * // Lists all the filters broken out into basic and advanced\n * Data.Filters.list();\n */\nexport class Filters extends Base {\n  /**\n   * Lists the values for a filter along with a total count of related views\n   *\n   * @param {string} filterId - The filter name/id for see https://api-docs.mux.com/#filter-get-1 for a list of all filter ids\n   * @param {Object} [queryParams] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Lists the values for a filter along with a total count of related views\n   * Data.Filters.get('browser', { timeframe: ['7:days'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-filter-values\n   *\n   * @deprecated The method should not be used, you should use Dimensions.get instead\n   */\n  get(\n    filterId: string,\n    params?: FilterQueryParams\n  ): Promise<FilterGetResponse> {\n    process.emitWarning(\n      'The Filter API has been deprecated, please use Dimension instead',\n      'DeprecatedWarning'\n    );\n    if (!filterId) {\n      throw new Error('Filter Id is required to get filter information.');\n    }\n    return this.http.get(`${PATH}/${filterId}`, { params });\n  }\n\n  /**\n   * Lists all the filters broken out into basic and advanced\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Lists the available video view exports along with URLs to retrieve them\n   * Data.Filters.list();\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-filters\n   *\n   * @deprecated The method should not be used, you should use Dimensions.list instead\n   */\n  list() {\n    process.emitWarning(\n      'The Filter API has been deprecated, please use Dimension instead',\n      'DeprecatedWarning'\n    );\n    return this.http.get(PATH);\n  }\n}\n","/*!\n * Mux Dimensions\n * Copyright(c) 2022 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport { DimensionGetResponse, DimensionQueryParams } from '../domain.js';\n\n/**\n * @private Base dimensions path for the Mux API\n * */\nconst PATH = '/data/v1/dimensions';\n\n/**\n * Dimensions Class - Provides access to the Mux Data Dimensions API\n *\n * @extends Base\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Data } = muxClient;\n *\n * // Lists all the dimensions broken out into basic and advanced\n * Data.Dimensions.list();\n */\nexport class Dimensions extends Base {\n  /**\n   * Lists the values for a dimension along with a total count of related views\n   *\n   * @param {string} dimensionId - The dimension name/id, see https://docs.mux.com/api-reference/data#operation/list-dimensions for a list of all dimensions\n   * @param {Object} [queryParams] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Lists the values for a dimension along with a total count of related views\n   * Data.Dimensions.get('browser', { timeframe: ['7:days'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-dimension-values\n   */\n  get(\n    dimensionId: string,\n    params?: DimensionQueryParams\n  ): Promise<DimensionGetResponse> {\n    if (!dimensionId) {\n      throw new Error('Dimension Id is required to get dimension information.');\n    }\n    return this.http.get(`${PATH}/${dimensionId}`, { params });\n  }\n\n  /**\n   * Lists all the dimensions broken out into basic and advanced\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Lists the available Data dimensions\n   * Data.Dimensions.list();\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-dimensions\n   */\n  list() {\n    return this.http.get(PATH);\n  }\n}\n","/*!\n * Mux Incidents\n * Copyright(c) 2019 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport {\n  IncidentsGetResponse,\n  IncidentsListResponse,\n  IncidentsQueryParams,\n  IncidentsRelatedQueryParams,\n} from '../domain.js';\n\n/**\n * @private Base incidents path for the Mux API\n * */\nconst PATH = '/data/v1/incidents';\n\n/**\n * Incidents Class - Provides access to the Mux Data Incidents API\n * @extends Base\n * @example\n * const { Data } = new Mux(accessToken, secret);\n *\n * // Returns a list of all open incidents\n * Data.Incidents.list({ status: 'open' });\n */\nexport class Incidents extends Base {\n  /**\n   * Returns a list of all open incidents\n   *\n   * @param {Object} [params] - example { status: 'open', severity: 'warning' }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const { Data } = new Mux(accessToken, secret);\n   *\n   * // Returns a list of all open incidents\n   * Data.Incidents.list({ status: 'open' });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-incidents\n   */\n  list(params?: IncidentsQueryParams): Promise<IncidentsListResponse> {\n    return this.http.get(PATH, { params });\n  }\n\n  /**\n   * Returns the details for a single incident\n   *\n   * @param {string} incidentId - The ID for the incident\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * //Returns the details for a single incident\n   * Data.Incidents.get('ABCD1234');\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-incident\n   */\n  get(incidentId: string): Promise<IncidentsGetResponse> {\n    if (!incidentId) {\n      throw new Error('An incident id is required for incident details.');\n    }\n    return this.http.get(`${PATH}/${incidentId}`);\n  }\n\n  /**\n   * Returns all the incidents that seem related to a specific incident\n   *\n   * @param {string} incidentId - The ID for the incident\n   * @param {Object} [params] - example { measurement: 'median' }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * //Returns all the incidents that seem related to a specific incident\n   * Data.Incidents.related('ABCD1234');\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-related-incidents\n   */\n  related(incidentId: string, params?: IncidentsRelatedQueryParams) {\n    if (!incidentId) {\n      throw new Error('An incident id is required for related incidents.');\n    }\n    return this.http.get(`${PATH}/${incidentId}/related`, { params });\n  }\n}\n","/*!\n * Mux Metrics\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport {\n  MetricsBreakdownQueryParams,\n  MetricsBreakdownResponse,\n  MetricsComparisonQueryParams,\n  MetricsComparisonResponse,\n  MetricsInsightsQueryParams,\n  MetricsInsightsResponse,\n  MetricsOverallQueryParams,\n  MetricsOverallResponse,\n  MetricsTimeseriesQueryParams,\n  MetricsTimeseriesResponse,\n} from '../domain.js';\n\n/**\n * @private Base metrics path for the Mux API\n * */\nconst PATH = '/data/v1/metrics';\n\n/**\n * Metrics Class - Provides access to the Mux Data Metrics API\n *\n * @extends Base\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Data } = muxClient;\n *\n * // List all of the values across every breakdown for a specific metric grouped by operating system\n * Data.Metrics.breakdown('aggregate_startup_time', { group_by: 'operating_system' });\n */\nexport class Metrics extends Base {\n  /**\n   * List the breakdown values for a specific metric\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#breakdown-get for a list of all metric ids\n   * @param {Object} params - example: {group_by: 'browser'}\n   * NOTE: the group_by query parameter is required\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // List all of the values across every breakdown for a specific metric grouped by browser\n   * Data.Metrics.breakdown('aggregate_startup_time', { group_by: 'browser' });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-breakdown-values\n   */\n  breakdown(\n    metricId: string,\n    params?: MetricsBreakdownQueryParams\n  ): Promise<MetricsBreakdownResponse> {\n    return this.http.get(`${PATH}/${metricId}/breakdown`, { params });\n  }\n\n  /**\n   * List all of the values across every breakdown for a specific metric\n   *\n   * @param {Object} params - example { value: 'safari', timeframe: '24:hours', dimension: 'cdn' }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // List the breakdown values for a specific metric within the last 24 hours\n   * Data.Metrics.comparison({ value: 'safari', timeframe: '24:hours', dimension: 'cdn' });\n   * Note: the value query parameter is required\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-all-metric-values\n   */\n  comparison(\n    params?: MetricsComparisonQueryParams\n  ): Promise<MetricsComparisonResponse> {\n    if (!params || (params && !params.value)) {\n      throw new Error(\n        'The value query parameter is required for comparing metrics'\n      );\n    }\n    return this.http.get(`${PATH}/comparison`, { params });\n  }\n\n  /**\n   * Returns a list of insights for a metric. These are the worst performing values across all\n   * breakdowns sorted by how much they negatively impact a specific metric.\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#breakdown-get for a list of all metric ids\n   * @param {Object} [params] - example { measurement: 'median', order_direction: 'desc' }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Get a list of insights for a metric measured by median and ordered descending\n   * Data.Metrics.insights('aggregate_startup_time', { measurement: 'median', order_direction: 'desc' });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-insights\n   */\n  insights(\n    metricId: string,\n    params?: MetricsInsightsQueryParams\n  ): Promise<MetricsInsightsResponse> {\n    if (!metricId) {\n      throw new Error('A metric Id is required for insight metrics.');\n    }\n    return this.http.get(`${PATH}/${metricId}/insights`, { params });\n  }\n\n  /**\n   * Returns the overall value for a specific metric, as well as the total view count,\n   * watch time, and the Mux Global metric value for the metric.\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#overall-get for a list of all metric ids\n   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Get the overall value for a specific metric within the past 7 days\n   * Data.Metrics.overall('aggregate_startup_time', { timeframe: ['7:days'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-overall-values\n   */\n  overall(\n    metricId: string,\n    params?: MetricsOverallQueryParams\n  ): Promise<MetricsOverallResponse> {\n    if (!metricId) {\n      throw new Error('A metric Id is required for overall metrics.');\n    }\n    return this.http.get(`${PATH}/${metricId}/overall`, { params });\n  }\n\n  /**\n   * Returns timeseries data for a specific metric\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#timeseries for a list of all metric ids\n   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Get timeseries data for a specific metric within the past 7 days\n   * Data.Metrics.timeseries('aggregate_startup_time', { timeframe: ['7:days'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-metric-timeseries-data\n   */\n  timeseries(\n    metricId: string,\n    params?: MetricsTimeseriesQueryParams\n  ): Promise<MetricsTimeseriesResponse> {\n    if (!metricId) {\n      throw new Error('A metric Id is required for timeseries metrics.');\n    }\n    return this.http.get(`${PATH}/${metricId}/timeseries`, { params });\n  }\n}\n","/*!\n * Mux Real-Time\n * Copyright(c) 2020 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport {\n  RealTimeBreakdownQueryParams,\n  RealTimeBreakdownResponse,\n  RealTimeDimensionsResponse,\n  RealTimeHistogramQueryParams,\n  RealTimeHistogramResponse,\n  RealTimeMetricsResponse,\n  RealTimeTimeseriesParams,\n  RealTimeTimeseriesResponse,\n} from '../domain.js';\n\n/**\n * @private Base real-time path for the Mux API\n * */\nconst PATH = '/data/v1/realtime';\n\n/**\n * Real-Time Class - Provides access to the Mux Data Real-Time API\n *\n * @extends Base\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Data } = muxClient;\n *\n * // Returns a list of available real-time dimensions\n * Data.RealTime.dimensions();\n */\nexport class RealTime extends Base {\n  /**\n   * List of available real-time dimensions\n   *\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Returns a list of available real-time dimensions\n   * Data.RealTime.dimensions();\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-realtime-dimensions\n   *\n   * @deprecated The method should not be used, you should use Monitoring.dimensions() instead\n   */\n  dimensions(): Promise<RealTimeDimensionsResponse> {\n    return this.http.get(`${PATH}/dimensions`);\n  }\n\n  /**\n   * List available real-time metrics\n   *\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Returns a list of available real-time metrics\n   * Data.RealTime.metrics();\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-realtime-metrics\n   *\n   * @deprecated The method should not be used, you should use Monitoring.metrics() instead\n   */\n  metrics(): Promise<RealTimeMetricsResponse> {\n    return this.http.get(`${PATH}/metrics`);\n  }\n\n  /**\n   * Get breakdown information for a specific dimension and metric along with the number of concurrent viewers and negative impact score.\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids\n   * @param {Object} params - example { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // List the breakdown information for current-concurrent-viewers by ASN for a specific time for the Windows operating system in the US\n   * Data.RealTime.breakdown('current-concurrent-viewers', { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-breakdown\n   *\n   * @deprecated The method should not be used, you should use Monitoring.breakdown() instead\n   */\n  breakdown(\n    metricId: string,\n    params?: RealTimeBreakdownQueryParams\n  ): Promise<RealTimeBreakdownResponse> {\n    if (!metricId) {\n      throw new Error(\n        'A metric Id is required for real-time breakdown information'\n      );\n    }\n\n    if (!params || (params && !params.dimension)) {\n      throw new Error(\n        'The dimension query parameter is required for real-time breakdown information'\n      );\n    }\n    return this.http.get(`${PATH}/metrics/${metricId}/breakdown`, { params });\n  }\n\n  /**\n   * List histogram timeseries information for a specific metric\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids\n   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // List histogram timeseries information for video-startup-time for the Windows operating system in the US\n   * Data.RealTime.histogramTimeseries('video-startup-time', { filters: ['operating_system:windows', 'country:US'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-histogram-timeseries\n   *\n   * @deprecated The method should not be used, you should use Monitoring.histogramTimeseries() instead\n   */\n  histogramTimeseries(\n    metricId: string,\n    params?: RealTimeHistogramQueryParams\n  ): Promise<RealTimeHistogramResponse> {\n    if (!metricId) {\n      throw new Error(\n        'A metric Id is required for real-time histogram timeseries information'\n      );\n    }\n    return this.http.get(`${PATH}/metrics/${metricId}/histogram-timeseries`, {\n      params,\n    });\n  }\n\n  /**\n   * List timeseries information for a specific metric along with the number of concurrent viewers.\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids\n   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // List timeseries information for the playback-failure-percentage metric along with the number of concurrent viewers for the Windows operating system in the US\n   * Data.RealTime.timeseries('playback-failure-percentage', { filters: ['operating_system:windows', 'country:US'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-timeseries\n   *\n   * @deprecated The method should not be used, you should use Monitoring.timeseries() instead\n   */\n  timeseries(\n    metricId: string,\n    params?: RealTimeTimeseriesParams\n  ): Promise<RealTimeTimeseriesResponse> {\n    if (!metricId) {\n      throw new Error(\n        'A metric Id is required for real-time timeseries information.'\n      );\n    }\n    return this.http.get(`${PATH}/metrics/${metricId}/timeseries`, {\n      params,\n    });\n  }\n}\n","/*!\n * Mux Monitoring\n * Copyright(c) 2020 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport {\n  MonitoringBreakdownQueryParams,\n  MonitoringBreakdownResponse,\n  MonitoringDimensionsResponse,\n  MonitoringHistogramQueryParams,\n  MonitoringHistogramResponse,\n  MonitoringMetricsResponse,\n  MonitoringTimeseriesParams,\n  MonitoringTimeseriesResponse,\n} from '../domain.js';\n\n/**\n * @private Base monitoring path for the Mux API\n * */\nconst PATH = '/data/v1/monitoring';\n\n/**\n * Monitoring Class - Provides access to the Mux Data Monitoring API\n *\n * @extends Base\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Data } = muxClient;\n *\n * // Returns a list of available monitoring dimensions\n * Data.Monitoring.dimensions();\n */\nexport class Monitoring extends Base {\n  /**\n   * List of available monitoring dimensions\n   *\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Returns a list of available monitoring dimensions\n   * Data.Monitoring.dimensions();\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-monitoring-dimensions\n   */\n  dimensions(): Promise<MonitoringDimensionsResponse> {\n    return this.http.get(`${PATH}/dimensions`);\n  }\n\n  /**\n   * List available monitoring metrics\n   *\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Returns a list of available monitoring metrics\n   * Data.Monitoring.metrics();\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-monitoring-metrics\n   */\n  metrics(): Promise<MonitoringMetricsResponse> {\n    return this.http.get(`${PATH}/metrics`);\n  }\n\n  /**\n   * Get breakdown information for a specific dimension and metric along with the number of concurrent viewers and negative impact score.\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids\n   * @param {Object} params - example { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // List the breakdown information for current-concurrent-viewers by ASN for a specific time for the Windows operating system in the US\n   * Data.Monitoring.breakdown('current-concurrent-viewers', { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-breakdown\n   */\n  breakdown(\n    metricId: string,\n    params?: MonitoringBreakdownQueryParams\n  ): Promise<MonitoringBreakdownResponse> {\n    if (!metricId) {\n      throw new Error(\n        'A metric Id is required for monitoring breakdown information'\n      );\n    }\n\n    if (!params || (params && !params.dimension)) {\n      throw new Error(\n        'The dimension query parameter is required for monitoring breakdown information'\n      );\n    }\n    return this.http.get(`${PATH}/metrics/${metricId}/breakdown`, { params });\n  }\n\n  /**\n   * List histogram timeseries information for a specific metric\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids\n   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // List histogram timeseries information for video-startup-time for the Windows operating system in the US\n   * Data.Monitoring.histogramTimeseries('video-startup-time', { filters: ['operating_system:windows', 'country:US'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-histogram-timeseries\n   */\n  histogramTimeseries(\n    metricId: string,\n    params?: MonitoringHistogramQueryParams\n  ): Promise<MonitoringHistogramResponse> {\n    if (!metricId) {\n      throw new Error(\n        'A metric Id is required for monitoring histogram timeseries information'\n      );\n    }\n    return this.http.get(`${PATH}/metrics/${metricId}/histogram-timeseries`, {\n      params,\n    });\n  }\n\n  /**\n   * List timeseries information for a specific metric along with the number of concurrent viewers.\n   *\n   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids\n   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // List timeseries information for the playback-failure-percentage metric along with the number of concurrent viewers for the Windows operating system in the US\n   * Data.Monitoring.timeseries('playback-failure-percentage', { filters: ['operating_system:windows', 'country:US'] });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-timeseries\n   */\n  timeseries(\n    metricId: string,\n    params?: MonitoringTimeseriesParams\n  ): Promise<MonitoringTimeseriesResponse> {\n    if (!metricId) {\n      throw new Error(\n        'A metric Id is required for monitoring timeseries information.'\n      );\n    }\n    return this.http.get(`${PATH}/metrics/${metricId}/timeseries`, {\n      params,\n    });\n  }\n}\n","/*!\n * Mux Video Views\n * Copyright(c) 2018 Mux Inc.\n */\nimport { Base } from '../../base.js';\nimport {\n  VideoView,\n  VideoViewsListResponse,\n  VideoViewsQueryParams,\n} from '../domain.js';\n\n/**\n * @private Base exports path for the Mux API\n * */\nconst PATH = '/data/v1/video-views';\n\n/**\n * VideoViews Class - Provides access to the Mux Data Video Views API\n *\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Data } = muxClient;\n *\n * // Returns a list of video views for a property that occurred within the specified timeframe.\n * // Results are ordered by view_end, according to what you provide for order_direction.\n * Data.VideoViews.list({order_direction: 'asc'});\n */\nexport class VideoViews extends Base {\n  /**\n   * Returns a list of video views for a property that occurred within the specified timeframe.\n   * Results are ordered by view_end, according to what you provide for order_direction.\n   *\n   * @extends Base\n   * @param {Object} queryParams - example { viewer_id: 'ABCD1234', timeframe: ['7:days'], filters: ['operating_system:windows'] }\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * // Returns a list of video views for a property that occurred within the specified timeframe.\n   * Data.VideoViews.list({ viewer_id: 'ABCD1234', timeframe: ['7:days'], order_direction: 'asc' });\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/list-video-views\n   */\n  list(params?: VideoViewsQueryParams): Promise<VideoViewsListResponse> {\n    return this.http.get(PATH, { params });\n  }\n\n  /**\n   * Returns the details for a single video view\n   *\n   * @param {string} videoViewId - The ID for the video view\n   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API\n   *\n   * @example\n   * const muxClient = new Mux(accessToken, secret);\n   * const { Data } = muxClient;\n   *\n   * //Returns the details for a single video view\n   * Data.VideoViews.get('ABCD1234');\n   *\n   * @see https://docs.mux.com/api-reference/data#operation/get-video-view\n   */\n  get(videoViewId: string): Promise<VideoView> {\n    if (!videoViewId) {\n      throw new Error('A video view Id is required for video view details.');\n    }\n    return this.http.get(`${PATH}/${videoViewId}`);\n  }\n}\n","/*!\n * Mux Data\n * Copyright(c) 2022 Mux Inc.\n */\n\nimport { Base } from '../base.js';\nimport { RequestOptions } from '../RequestOptions.js';\n\nimport { Errors } from './resources/errors.js';\nimport { Exports } from './resources/exports.js';\nimport { Filters } from './resources/filters.js';\nimport { Dimensions } from './resources/dimensions.js';\nimport { Incidents } from './resources/incidents.js';\nimport { Metrics } from './resources/metrics.js';\nimport { RealTime } from './resources/real_time.js';\nimport { Monitoring } from './resources/monitoring.js';\nimport { VideoViews } from './resources/video_views.js';\n\n/**\n * @ignore\n * @extends Base\n * Data Class - Provides access to the Mux Data API\n *\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Data } = muxClient;\n *\n */\nexport class Data extends Base {\n  readonly Errors: Errors;\n  readonly Exports: Exports;\n  readonly Filters: Filters;\n  readonly Dimensions: Dimensions;\n  readonly Incidents: Incidents;\n  readonly Metrics: Metrics;\n  readonly RealTime: RealTime;\n  readonly Monitoring: Monitoring;\n  readonly VideoViews: VideoViews;\n\n  /**\n   * Data Constructor\n   *\n   * @param {string} accessToken - Mux API Access Token\n   * @param {string} secret - Mux API secret\n   * @constructor\n   */\n  constructor(base: Base);\n  constructor(config: RequestOptions);\n  constructor(accessToken: string, secret: string, config: RequestOptions);\n  constructor(\n    accessTokenOrConfigOrBase: string | RequestOptions | Base,\n    secret?: string,\n    config?: RequestOptions\n  ) {\n    if (accessTokenOrConfigOrBase instanceof Base) {\n      super(accessTokenOrConfigOrBase);\n    } else if (typeof accessTokenOrConfigOrBase === 'object') {\n      super(accessTokenOrConfigOrBase);\n    } else {\n      super(accessTokenOrConfigOrBase, secret!, config!);\n    }\n\n    /** @type {Errors} */\n    this.Errors = new Errors(this);\n\n    /** @type {Exports} */\n    this.Exports = new Exports(this);\n\n    /** @type {Filters} */\n    this.Filters = new Filters(this);\n\n    /** @type {Dimensions} */\n    this.Dimensions = new Dimensions(this);\n\n    /** @type {Incidents} */\n    this.Incidents = new Incidents(this);\n\n    /** @type {Metrics} */\n    this.Metrics = new Metrics(this);\n\n    /** @type {RealTime} */\n    this.RealTime = new RealTime(this);\n\n    /** @type {Monitoring} */\n    this.Monitoring = new Monitoring(this);\n\n    /** @type {VideoViews} */\n    this.VideoViews = new VideoViews(this);\n  }\n}\n","import crypto from 'crypto';\n\nexport const HeaderScheme = {\n  V1: 'v1',\n} as const;\n// eslint-disable-next-line no-redeclare\nexport type HeaderScheme = typeof HeaderScheme[keyof typeof HeaderScheme];\n\nconst DEFAULT_TOLERANCE = 300; // 5 minutes\nconst EXPECTED_SCHEME: HeaderScheme = HeaderScheme.V1;\n\n/**\n * Secure compare, from https://github.com/freewil/scmp\n */\nfunction secureCompare(_a: string, _b: string) {\n  const a = Buffer.from(_a);\n  const b = Buffer.from(_b);\n\n  // return early here if buffer lengths are not equal since timingSafeEqual\n  // will throw if buffer lengths are not equal\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // use crypto.timingSafeEqual if available (since Node.js v6.6.0),\n  // otherwise use our own scmp-internal function.\n  if (crypto.timingSafeEqual) {\n    return crypto.timingSafeEqual(a, b);\n  }\n\n  const len = a.length;\n  let result = 0;\n\n  for (let i = 0; i < len; i += 1) {\n    /* eslint-disable no-bitwise */\n    result |= a[i] ^ b[i];\n  }\n  return result === 0;\n}\n\nexport class VerifyHeader {\n  static parseHeader(header?: string, scheme: HeaderScheme = HeaderScheme.V1) {\n    if (typeof header !== 'string') {\n      return null;\n    }\n\n    if (scheme !== EXPECTED_SCHEME) {\n      throw new Error(`Unrecognized header scheme: '${scheme}'`);\n    }\n\n    return header.split(',').reduce(\n      (accum, item) => {\n        const kv: string[] = item.split('=');\n\n        if (kv[0] === 't') {\n          /* eslint-disable no-param-reassign, prefer-destructuring */\n          accum.timestamp = parseInt(kv[1], 10);\n        }\n\n        if (kv[0] === scheme && typeof kv[1] === 'string') {\n          accum.signatures.push(kv[1]);\n        }\n\n        return accum;\n      },\n      {\n        timestamp: -1,\n        signatures: [] as string[],\n      }\n    );\n  }\n\n  static computeSignature(payload: string, secret: string | Buffer) {\n    return crypto\n      .createHmac('sha256', secret)\n      .update(payload, 'utf8')\n      .digest('hex');\n  }\n\n  static verify(\n    _payload: string | Buffer,\n    _header: string | Buffer,\n    secret: string | Buffer,\n    tolerance: number = DEFAULT_TOLERANCE\n  ) {\n    const payload = Buffer.isBuffer(_payload)\n      ? _payload.toString('utf8')\n      : _payload;\n    const header = Buffer.isBuffer(_header)\n      ? _header.toString('utf8')\n      : _header;\n\n    const details = this.parseHeader(header);\n\n    if (!details || details.timestamp === -1) {\n      throw new Error('Unable to extract timestamp and signatures from header');\n    }\n\n    if (!details.signatures.length) {\n      throw new Error('No signatures found with expected scheme');\n    }\n\n    const expectedSignature = this.computeSignature(\n      `${details.timestamp}.${payload}`,\n      secret\n    );\n\n    const signatureFound = !!details.signatures.filter((sig) =>\n      secureCompare(sig, expectedSignature)\n    ).length;\n\n    if (!signatureFound) {\n      throw new Error(\n        'No signatures found matching the expected signature for payload.'\n      );\n    }\n\n    const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n\n    if (tolerance > 0 && timestampAge > tolerance) {\n      throw new Error('Timestamp outside the tolerance zone');\n    }\n\n    return true;\n  }\n}\n","import { VerifyHeader } from './resources/verify_header.js';\n\n/**\n * Webhooks - Provides access to the Mux Webhooks signature verification\n *\n * @example\n * const Mux = require('@mux/mux-node');\n * const { Webhooks } = Mux;\n *\n * // Verify a webhook signature\n * Webhooks.verifyHeader(body, signature, secret);\n *\n */\nexport class Webhooks {\n  /**\n   * Verify a webhook signature. When enabled, Mux will send webhooks with a signature\n   * in the http request header 'Mux-Signature'. You can use that signature to verify\n   * that the webhook is indeed coming from Mux.\n   *\n   * @param {string} body - The raw request body from Mux. This is stringified JSON.\n   * @param {string} signature - The signature that was in the request header.\n   * @param {string} secret - The webhook signing secret (get this from your dashboard).\n   * @returns {boolean} - Returns true if the signature is verified.\n   *\n   * @throws {Error} throw error when a webhook signature verification fails.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   * const { Webhooks } = Mux;\n   *\n   * // Verify a webhook signature\n   * Webhooks.verifyHeader(body, signature, secret);\n   *\n   * @see https://docs.mux.com/docs/webhook-security\n   */\n  static verifyHeader(\n    body: string | Buffer,\n    signature: string,\n    secret: string\n  ) {\n    return VerifyHeader.verify(body, signature, secret);\n  }\n}\n","/*!\n * JWT - Signed URL Helpers\n * Note: Hacking this module into a class with static methods because ESDoc forces it. We'll revisit ESDoc later.\n * Documentationjs looks real nice.\n */\nimport fs from 'fs';\nimport jwt from 'jsonwebtoken';\n\n// eslint-disable-next-line no-shadow\nexport enum TypeClaim {\n  video = 'v',\n  thumbnail = 't',\n  gif = 'g',\n  storyboard = 's',\n  stats = 'playback_id',\n}\n\n// eslint-disable-next-line no-shadow\nexport enum DataTypeClaim {\n  video = 'video_id',\n  asset = 'asset_id',\n  playback = 'playback_id',\n  live_stream = 'livestream_id',\n}\n\nexport interface MuxJWTSignOptions {\n  keyId?: string;\n  keySecret?: string;\n  keyFilePath?: string;\n  type?: string;\n  expiration?: string;\n  params?: Record<string, string>;\n}\n\nconst getSigningKey = (options: MuxJWTSignOptions) => {\n  const keyId = options.keyId || process.env.MUX_SIGNING_KEY;\n  if (!keyId) {\n    throw new TypeError('Signing Key ID required');\n  }\n\n  return keyId;\n};\n\nconst getPrivateKey = (options: MuxJWTSignOptions): string | Buffer => {\n  let key;\n  if (options.keySecret) {\n    key = options.keySecret;\n  } else if (options.keyFilePath) {\n    key = fs.readFileSync(options.keyFilePath);\n  } else if (process.env.MUX_PRIVATE_KEY) {\n    key = Buffer.from(process.env.MUX_PRIVATE_KEY, 'base64');\n  }\n\n  if (Buffer.isBuffer(key)) {\n    return key;\n  }\n\n  if (key) {\n    const [rsaHeader] = key.toString().split('\\n');\n    if (rsaHeader === '-----BEGIN RSA PRIVATE KEY-----') {\n      return key;\n    }\n\n    try {\n      return Buffer.from(key, 'base64');\n    } catch (err) {\n      throw new TypeError(\n        'Specified signing key must be either a valid PEM string or a base64 encoded PEM.'\n      );\n    }\n  }\n\n  throw new TypeError('Signing Key ID required');\n};\n\n/**\n * JWT - Signed URL token generation helpers\n *\n * @example\n * const Mux = require('@mux/mux-node');\n *\n * const token = Mux.JWT.signPlaybackId('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' })\n */\nexport class JWT {\n  /**\n   * Creates a new token to be used with a signed playback ID\n   * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, `storyboard` or `stats`\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n   * @returns {string} - Returns a token to be used with a signed URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`\n   *\n   * @deprecated This method should not be used, you should use signPlaybackId instead\n   */\n  static sign(playbackId: string, options: MuxJWTSignOptions = {}) {\n    process.emitWarning(\n      'The JWT.sign() method has been deprecated, please use JWT.signPlaybackId() instead',\n      'DeprecatedWarning'\n    );\n    return this.signPlaybackId(playbackId, options);\n  }\n  /**\n   * Creates a new token to be used with a signed playback ID\n   * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, `storyboard` or `stats`\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n   * @returns {string} - Returns a token to be used with a signed URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.signPlaybackId('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`\n   */\n  static signPlaybackId(playbackId: string, options: MuxJWTSignOptions = {}) {\n    const opts = {\n      type: 'video',\n      expiration: '7d',\n      params: {},\n      ...options,\n    };\n\n    const keyId = getSigningKey(options);\n    const keySecret = getPrivateKey(options);\n\n    // TODO: come back through sometime and replace this with runtypes validation?\n    // @ts-ignore\n    const typeClaim = TypeClaim[opts.type];\n    if (!typeClaim) {\n      throw new Error(`Invalid signature type: ${opts.type}`);\n    }\n\n    const tokenOptions: jwt.SignOptions = {\n      keyid: keyId,\n      subject: playbackId,\n      audience: typeClaim,\n      expiresIn: opts.expiration,\n      noTimestamp: true,\n      algorithm: 'RS256',\n    };\n\n    return jwt.sign(opts.params, keySecret, tokenOptions);\n  }\n  /**\n   * Creates a new token to be used with a signed Space ID\n   * @param {string} spaceId - The Space ID (of type 'signed') that you'd like to generate a token for.\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url.\n   * @returns {string} - Returns a token to be used with a signed URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.signSpaceId('some-space-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   */\n  static signSpaceId(spaceId: string, options: MuxJWTSignOptions = {}) {\n    const opts = {\n      expiration: '7d',\n      params: {},\n      ...options,\n    };\n\n    const keyId = getSigningKey(options);\n    const keySecret = getPrivateKey(options);\n\n    const tokenOptions: jwt.SignOptions = {\n      keyid: keyId,\n      subject: spaceId,\n      audience: 'rt',\n      expiresIn: opts.expiration,\n      noTimestamp: true,\n      algorithm: 'RS256',\n    };\n\n    if (!spaceId) {\n      throw new TypeError('A valid Space ID is required');\n    }\n\n    return jwt.sign(opts.params, keySecret, tokenOptions);\n  }\n\n  /**\n   * Creates a new token to be used with a signed statistics request\n   * @param {string} Id - The ID of the object that you'd like to generate a token for\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `asset`, `playback`, or `live_stream`\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n   * @returns {string} - Returns a token to be used with a viewer count URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.signViewerCounts('some-id', { type: 'video', keyId: 'your key id', keySecret: 'your key secret' });\n   * // Now you can use the token in a url: `https://stats.mux.com/counts?token=${token}`\n   */\n  static signViewerCounts(Id: string, options: MuxJWTSignOptions = {}) {\n    const opts = {\n      type: 'video',\n      expiration: '7d',\n      params: {},\n      ...options,\n    };\n\n    const keyId = getSigningKey(options);\n    const keySecret = getPrivateKey(options);\n\n    // TODO: come back through sometime and replace this with runtypes validation?\n    // @ts-ignore\n    const typeClaim = DataTypeClaim[opts.type];\n    if (!typeClaim) {\n      throw new Error(`Invalid signature type: ${opts.type}`);\n    }\n\n    const tokenOptions: jwt.SignOptions = {\n      keyid: keyId,\n      subject: Id,\n      audience: typeClaim,\n      expiresIn: opts.expiration,\n      noTimestamp: true,\n      algorithm: 'RS256',\n    };\n\n    return jwt.sign(opts.params, keySecret, tokenOptions);\n  }\n\n  /**\n   * Decodes an existing token.\n   *\n   * Note: This does not cryptographically verify the token signature, it simply decodes the values.\n   * @param {string} token - The token you'd like to decode.\n   * @returns {Object} - If the token could be decoded, it returns the decoded token object\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * const decoded = Mux.JWT.decode(token);\n   * // decoded will be the raw decoded JWT, so you'll see keys like `aud`, `exp`, etc.\n   */\n  static decode(token: string) {\n    return jwt.decode(token);\n  }\n}\n","/*!\n * Mux\n * Copyright(c) 2018 Mux Inc.\n */\n\nimport { Base } from './base.js';\nimport { Video } from './video/video.js';\nimport { Data } from './data/data.js';\nimport { Webhooks } from './webhooks/webhooks.js';\nimport { JWT } from './utils/jwt.js';\n\nimport { RequestOptions } from './RequestOptions.js';\n\n/**\n * Mux Class - Provides access to the Mux Video and Mux Data API\n *\n * @extends Base\n * @type {Video}\n * @property {Video} Mux.Video provides access to the Mux Video API\n * @type {Data}\n * @property {Data} Mux.Data provides access to the Mux Data API\n * @type {Webhooks}\n * @property {Webhooks} Mux.Webhooks provides access to verifying Webhooks signatures\n * @example\n * const muxClient = new Mux(accessToken, secret);\n * const { Video, Data, Webhooks } = muxClient;\n *\n * // Create an asset\n * // returns a Promise\n * Video.Assets.create({input: 'https://storage.googleapis.com/muxdemofiles/mux-video-intro.mp4'})\n *   .then((data) => {\n *     assetId = data.id;\n *   });\n *\n * // Create a playback Id for an asset\n * // returns a Promise\n * Video.Assets.createPlaybackId(assetId, { policy: 'public' });\n *\n * // List all of the values across every breakdown for the `aggregate_startup_time` metric\n * // returns a Promise\n * Data.Metrics.breakdown('aggregate_startup_time', { group_by: 'browser' });\n\n * // Verify a webhook signature\n * Webhooks.verifyHeader(body, signature, secret);\n */\nexport default class Mux extends Base {\n  static readonly JWT = JWT;\n  static readonly Webhooks = Webhooks;\n\n  readonly Video: Video;\n  readonly Data: Data;\n\n  /**\n   * Mux Constructor\n   *\n   * @param {string=process.env.MUX_TOKEN_ID} accessToken - Mux API Access Token\n   * @param {string=process.env.MUX_TOKEN_SECRET} secret - Mux API secret\n   * @param {object} options - Optional configuration object\n   * @param {string='https://api.mux.com'} options.baseUrl - Change the base URL for API requests.\n   * @constructor\n   */\n  constructor();\n  constructor(config: RequestOptions);\n  constructor(accessToken: string, secret: string);\n  constructor(accessToken: string, secret: string, config: RequestOptions);\n  constructor(\n    accessTokenOrConfig?: string | RequestOptions,\n    secret?: string,\n    config?: RequestOptions\n  ) {\n    // disabled because it's an overload issue; you can't have\n    // defaults in constructor overloads so you have to kind of fake it?\n    // eslint-disable-next-line no-param-reassign\n    accessTokenOrConfig = accessTokenOrConfig ?? {};\n\n    if (typeof accessTokenOrConfig === 'object') {\n      super(accessTokenOrConfig);\n    } else {\n      super(accessTokenOrConfig, secret!, config ?? {});\n    }\n\n    /** @type {Video} */\n    this.Video = new Video(this);\n\n    /** @type {Data} */\n    this.Data = new Data(this);\n  }\n}\n\nexport * from './data/domain';\nexport * from './video/domain';\n"],"mappings":"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","names":[]}